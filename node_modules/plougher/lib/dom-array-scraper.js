var Async           = require('async');
var Utils           = require('../lib/utils');
var _               = require('underscore');

var internals       = {};

function DomArrayScraper(_variables) {
    this._variables = _variables;
};

/**
 *  Init function for Array scraper.
 */
DomArrayScraper.prototype.scrape = function(config, done) {
    if (!config) {
        console.error('No config provided');
        return done();
    }

	config.type = config.type || "string";

    if (config.type === 'string') {
        return this.scrapeStringArray(config, done);
    }

    if (config.type === 'object') {
        return this.scrapeObjectArray(config, done);
    }
};

/**
 *  Scrape the default string type
 */
DomArrayScraper.prototype.scrapeStringArray = function(config, done) {
    var join            = config.join || "",
        $               = this._variables.$,
        resultsArray    = [],
        elementArray    = [],
        that            = this;
   
    if (config.find_attr && !config.find) {
        throw new Error('find_attr must come together with find');
    }

    //get the result in the root object, then reach for the value and replaces any handles on the result 
    config.path = config.path.replace(/\{\{(.*)\}\}/g, 
                  Utils.reachForValue.bind(this));

    // For every string that is found
    $(config.path).each(function() {
        var string;
        
        if (config.attr) {
            string = $(this).attr(config.attr);
        } else {
            string = $(this).text();
        }

        //if suffix of prefix is a reference, get the value
        if (config.suffix && config.suffix.indexOf('}}') > -1) {
            config.suffix = Utils.reachForValue.call(that, config.suffix);
        }

        if (config.prefix && config.prefix.indexOf('}}') > -1) {
            config.prefix = Utils.reachForValue.call(that, config.prefix);
        }
        
        string = Utils.processStringValue(config, string);
        if (!string) {
            return;
        }
        
        resultsArray.push(string);
        if (config.find && config.find_attr) {
            elementArray.push($(this).attr(config.find_attr));
        }
    });
    
    if (resultsArray.length < 1) {
        return done();
    }

    //if find flag is provided, find the first occurence of it and return it
    if (config.find) {
        var findTarget = config.find,
            foundElement;
        
        //if find is a reference, get the value
        if (config.find.indexOf('}}') > -1) {
            findTarget = Utils.reachForValue.call(that, config.find);
        }

        for (var index in resultsArray) {
            if ((config.find_attr ? elementArray[index] : resultsArray[index]).indexOf(findTarget) > -1) {
                foundElement = resultsArray[index];
                break;
            }
        }
       
        if (foundElement) {
            return done(null, foundElement);
        }
        
        console.warn("No element could be found in " + resultsArray + " with search " + config.find);
        return done();
    }

    //if unique flag does not exist unique defaults to true, 
    if (config.unique !== false) {
        resultsArray = _.uniq(resultsArray);
    }
    
    //if we should flatten it
    if (config.flatten) {
        resultsArray = resultsArray.join(join);
        resultsArray = resultsArray + join.trim();
    }

    if (config.filter) {
        return this.filterArrayWithCondition(config.filter, resultsArray, done);
    }

    return done(null, resultsArray);
};

/**
 *  Scrape the type object, this creates an array of object in the end rather than just an array of values.
 */
DomArrayScraper.prototype.scrapeObjectArray = function(config, done) {
    if (config.follow) {
        throw new Error('Follow flag is only supported for arrays of strings (urls).');
    }
    
    if (!config.mapping) {
        throw new Error('A mapping must be provided when creating arrays with objects.');
    }
    
    var results = [],
        $       = this._variables.$,
        that    = this,
        items   = $(config.path);
    

    Async.mapSeries(items, function(i, callback) {
        var html = $.html(items[i]);
         
        if (!html) {
            return callback();
        }
        
        Utils.extractFromWithin(config.mapping, html, function(err, result) {
            results.push(result);
            callback();
        }, that._variables);
    }, function() {
        return done(null, results);
    });
};


/**
 *  Removes the items from the array that does not match the condition provided
 */
DomArrayScraper.prototype.filterArrayWithCondition = function(condition, array, done) {
    var targetValue;
    
    if (condition.indexOf("_") > -1) {
        var values  = condition.split('_'),
            condition = values[0];
    }
    
    switch (condition) {
        case "!contains" :
            if (!values || !values.length === 2) {
                throw new Error('Invalid format of array-filter-contains');
            }
            
            if (values[1].indexOf('}}') > -1) {
                targetValue = Utils.reachForValue.call(this, values[1]);
            } else {
                targetValue = values[1];
            }
            
            array = array.filter(function(element){
                return (element.indexOf(targetValue) === -1);
            });
            
            return done(null, array);
    
        case "contains" :
            if (!values || !values.length === 2) {
                throw new Error('Invalid format of array-filter-contains');
            }
            
            if (values[1].indexOf('}}') > -1) {
                targetValue = Utils.reachForValue.call(this, values[1]);
            } else {
                targetValue = values[1];
            }
            
            array = array.filter(function(element){
                return (element.indexOf(targetValue) > -1);
            });
            
            return done(null, array);
        
        case "followable" :
            Async.filterSeries(array, Utils.checkLink, function(result) {
                done(null, result);
            });

            break;
        default : 
            throw new Error(condition + " not supported for filters.");
    }
}

module.exports = exports = DomArrayScraper;

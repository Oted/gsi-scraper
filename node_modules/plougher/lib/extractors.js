var Utils               = require('./utils');
var Cheerio             = require('cheerio');
var Hoek                = require('hoek');
var Async               = require('async');
var Request             = require('request');

var DebugResult         = require('debug')('result');
var DebugCondition      = require('debug')('condition');

var DomStringScraper    = require('./dom-string-scraper'),
    DomArrayScraper     = require('./dom-array-scraper'),
    DomScriptScraper    = require('./dom-script-scraper'),
    JsonEndpointScraper = require('./json-endpoint-scraper');


/**
 *  The intention of this object is to take care of all calls to the scrapers,
 *  creating a new extractor with new externals should create a new instance of result.
 */
function Extractors(html, config, parentVariables) {
    if (!html) {
        throw new Error('No html provided for extractors.');
    }
    
    if (!config) {
        throw new Error('No config provided for extractors.');
    }
    
    var _variables = {};

    //add configuration to _variables
    _variables.html         = html;
    _variables.$            = Cheerio.load(html);
    //the root config
    _variables.config       = config;
    //final result
    _variables.result       = {};
    //cache for script
    _variables.scriptCache  = {};
    //the parents _varaibles or null
    _variables.parent       = parentVariables || null; 

    if (!_variables.$) {
        throw new Error('Could not load cheerio ($) for plougher.');
    }
    
    //_variables contains all information nedded by this instance of Extractors,
    //all scrapers can access _variables with this._variables
    this._variables = _variables;
    
    //create unique instances of the scrapers and inject the dependency
    this.scrapers = {
        'jsonEndpointScraper' : new JsonEndpointScraper(_variables),
        'domScriptScraper'    : new DomScriptScraper(_variables),
        'domArrayScraper'     : new DomArrayScraper(_variables),
        'domStringScraper'    : new DomStringScraper(_variables)
    };
}; 


/**
 *  Init method for scraping.
 */
Extractors.prototype.extract = function(done) {
    this.scrapeKeys(this._variables.config, null, done);
};


/**
 *  Method for scraping one specific key. 
 */
Extractors.prototype.scrapeKeys = function(config, key, done) {
    var shouldFollow = config.follow ? true : false,
        that = this;
   
    //if this config contains a fallback, call the fallbackHndler
    if (config["try"]) {
        return this.handleTry(key, config["try"], this.assignResult.bind(this, key, done));
    }
   
    //handles switch statements
    if (config["switch"]) {
        return this.handleSwitch(key, config, this.assignResult.bind(this, key, done));
    }
    
    //if this config contains conditions, call the conditionHandler
    if (config["conditions"]) {
        return Utils.handleConditions.call(this, config, function(pass) {
            return that.scrapeKeys(config[pass], key, done);
        });
    }
  
    //otherwise were dealing with a normal extractor
    switch (config.extractor) {
        case 'dom_object' : 
            if (!key) {
                return this.domObjectExtractor(config, this.assignResult.bind(this, key, done));
            } else {
                return Utils.extractFromWithin(config, this._variables.html, this.assignResult.bind(this, key, done), this._variables);
            }

        case 'dom_string' : 
            if (shouldFollow) {
                return that.scrapers.domStringScraper.scrape(config, this.followUrl.bind(this, config, this.assignResult.bind(this, key, done)));
            } else {
                return that.scrapers.domStringScraper.scrape(config, this.assignResult.bind(this, key, done));
            }

        case 'dom_array' : 
            if (shouldFollow) {
                return that.scrapers.domArrayScraper.scrape(config, this.followUrls.bind(this, config, this.assignResult.bind(this, key, done)));
            } else {
                return that.scrapers.domArrayScraper.scrape(config, this.assignResult.bind(this, key, done));
            }

        case 'json_endpoint' : 
            return that.scrapers.jsonEndpointScraper.scrape(config, this.assignResult.bind(this, key, done));

        case 'dom_script' : 
            return that.scrapers.domScriptScraper.scrape(config, this.assignResult.bind(this, key, done));

        case 'reference' : 
            return this.assignResult.call(this, key, done, null, Utils.reachForValue.call(this, config['value']));

        case 'constant' :
            return this.assignResult.call(this, key, done, null, config['value']);

        default :
            return done(new TypeError("This config extractor is not supported on key " + key + ": " + config.extractor + "."));
    }
};

/**
 *  Handles the 'dom_object' key
 */
Extractors.prototype.domObjectExtractor = function(config, done) {
    if (!config.extractor) {
        return done(new TypeError('Please specify the extractor type.'));
    }
    
    var keys            = Object.keys(config.keys),
        that            = this;
    
    //For every key we need to scrape, add it to the tasks
    Async.eachSeries(keys, function(key, callback) {
        that.scrapeKeys(config.keys[key], key, callback);
    }, done);
};


/**
 *  Assign the returned result from the scraper to the final result object.
 */
Extractors.prototype.assignResult = function(key, done, err, result) {
   if (err) {
        return done(err);
    }

    //debug 'result'
    DebugResult('Result for key ' + key + ' was ' + JSON.stringify(result, null, " "));
 
    //if there is a key provided assign the results key to it 
    if (key) {
        this._variables.result[key] = result;
    } 
    
    //if there is a result provided but no key, and object is empty the final result should not be an obejct
    else if ((result || !isNaN(result))) {
        this._variables.result = result;
    } 
    
    return done(null, this._variables.result); 
};


/**
 *  Tries to follow the url and scrape the new page with the given mapping.
 */
Extractors.prototype.followUrl = function(config, done, err, url) {
    var that = this;
    if (!url) {
        console.error("No url to follow, returning null");
        return done();
    }

    if (!config.mapping) {
        return done(new TypeError('When follow is true, a mapping must be provided.'));
    }

    if (err) {
        return done(err);
    }
    
    //gets the html and then calls extractFromwithin with it
    Utils.getHtml(url, function(err, html) {
        if (!html || err) {
            console.log('Could not get html from url ' + url + ', returning null');
            return done(null);
        }

        Utils.extractFromWithin(config.mapping, html, done);
    });
};


/**
 *  Tries to follow the urls and scrape the new page with the given mapping.
 */
Extractors.prototype.followUrls = function(config, done, err, urls) {
    var that = this;
    
    if (!urls) {
        console.error('Could not follow urls, the list of urls was undefied.');
        if (config["add_current"]) {
            return Utils.extractFromWithin(config.mapping, that._variables.html, function(err, result) {
                if (err) {
                    console.log('An error occured when adding current page, \n' + err); 
                }

                return done(null, [result]);
            });
        }

        return done();
    }

    //traverse all urls returned from array and call followUrl
    Async.mapLimit(urls, 10, function(url, callback) {
        that.followUrl(config, callback, null, url);
    }, function(err, results) {
        if (err) {
            console.log(err);
        }
        
        //if we want to add the current page, unshift it to the result array
        if (config.add_current) {
            Utils.extractFromWithin(config.mapping, that._variables.html, function(err, result) {
                if (err) {
                    console.log('An error occured when adding current page, \n' + err); 
                }

                results.unshift(result);
            });
        }

        return done(null, results);
    });
};

/**
 * Handle the fallbacks array, creates wrapping functions each of the tries and the standard mapping
 * and put them in order. Then call aync series on them, if no function returned a value, null is returned.
 */
Extractors.prototype.handleTry = function(key, tryArray, done) {
    var that        = this,
        finalValue  = null;

    if (!tryArray || tryArray.length === 0) {
        console.error('Something went wrong in try clause, the array seems to be empty');
        return done();
    }
        
    //callback function for each item in try
    var wrapper = function(item, callback) {
        that.scrapeKeys(item, key, function(err, result) {
            var value; 
            
            if (err) {
                return callback(err);
            }
            
            if (typeof result === 'object') {
                value = result[key];
            } else {
                value = result;
            }

            finalValue = value;

            //if this is an array, check if the length is 0
            if (value && Array.isArray(value)) {
                return callback(value.length !== 0);
            }

            //if this is an object, check if its empty
            if (value && typeof value === 'object') {
                return callback(Object.keys(value).length !== 0);
            }

            return callback(value ? true : false);
        });
    };

    Async.detectSeries(tryArray, wrapper, function(result) {
        return done(null, finalValue);
    });
};


/**
 *  Handles the switch statements.
 */
Extractors.prototype.handleSwitch = function(key, switchConfig, done) {
    var that        = this,
        finalValue  = null;

    if (!switchConfig) {
        console.error('Something went wrong in switch clause.');
        return done();
    }

    if (!switchConfig.target) {
        console.error('Switch must be provided with a target.');
        return done();
    }

    if (!switchConfig.switch || switchConfig.switch.length === 0) {
        console.error('Switch must be provided with array of length > 0.');
        return done();
    }

    //get the target mapping
    Utils.extractFromWithin(switchConfig.target, that._variables.html, function(err, result) {
        var foundIndex = -1;

        if (err) {
            return done(err);
        }

        if (!result) {
            console.error('No result found in target mapping for switch.');
            return done();
        }
        
        for (var index in switchConfig.switch) {
            var _case       = switchConfig.switch[index];
            
            if (_case.value === result) {
                foundIndex = index;
                break;
            }
        }
      
        if (foundIndex < 0) {
            console.error('No values matched ' + JSON.stringify(result, null, " ") + ' in switch array, resturning null.');
            return done();
        }
       
        //get the result with the correct mapping in case array
        Utils.extractFromWithin(switchConfig.switch[foundIndex].mapping, that._variables.html, function(err, doc) {
            if (err) {
                return done(err);
            }
        
            return done(err, doc);
        }, that._variables);
    }, that._variables);
};

module.exports = exports = Extractors;

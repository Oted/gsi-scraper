var Hoek        = require('hoek'),
    Async       = require('async'),
    Request     = require('request'),
    _           = require('underscore'),
    Debug       = require('debug')('function');

/**
 *  Gets html from a given url or null if something went wrong.
 */
module.exports.getHtml = function() {
    var url, retries, done;
    url = arguments[0];

    if (typeof arguments[1] === 'function') {
        done = arguments[1];
        retries = 3;
    } else {
        retries = arguments[1];
        done = arguments[2];
    }

    Request(url, {timeout : 2000}, function(err, res, html) {
        if (err || !html) {
            if (retries === 1) {
                return done(err);
            }

            return module.exports.getHtml(url, retries-1, done);
        }

        return done(null, html);
    });
};

/**
 *  Gets the root parent _varaibles
 */
module.exports.getRootVariables = function(_varaibles) {
    if (!_varaibles.parent) {
        return _varaibles;
    }
    
    return module.exports.getRootVariables(_varaibles.parent);    
};

/**
 *  Creates a new extractor and gets the result, useful when there is a subparts of html or a foregin 
 *  site that needs to be scraped.
 */
module.exports.extractFromWithin = function(config, innerHtml, done, parentVariables) {
    var Extractors      = require('./extractors');
    var innerExtractor  = new Extractors(innerHtml, config, parentVariables);

    //execute inner extractors and resturn result
    innerExtractor.extract(function(err, result) {
        if (err) {
            return done(err, null);
        }
        
        return done(null, result);
    });
};


/**
 *  Get the actual value at the key in the handles by replacing the wrapper wings 
 *  and reach for the object with hoek.
 */
module.exports.reachForValue = function(propertyPath) {
    var destinationObject = module.exports.getRootVariables(this._variables).result;
    
    if (!destinationObject) {
        destinationObject = this._variables.result;
    }
    
    propertyPath = propertyPath.replace('{{', '').replace('}}', '');
    return Hoek.reach(destinationObject, propertyPath);
};


/**
 *  Handles transformations of strings such as converting to numbers and replacements.
 */
module.exports.processStringValue = function(config, value) {
    if (!value) {
        return null;
    }

    var prefix = config.prefix || "";
    var suffix = config.suffix || "";

    //strip stuff from the result 
    if (config.strip) {
        switch (config.strip) {
            //strip html
            case "html" :
                value = value.replace(/<\/?[^>]+(>|$)/g, "").trim();
                break;
        }
    }

    //parses string to number
    if (config.type && config.type === 'number') {
        value = parseFloat(value.replace(/[^0-9\.]+/g, ''));
        if (isNaN(value)) {
            value = null;
            return value;
        }

        return value;
    }
    
    if (!config.functions) {
        return prefix + value + suffix;
    }

    if (!Array.isArray(config.functions)) {
        throw new Error('Please ensure \'functions\' is an array of objects, not a single object');
    }

    //apply all functions
    return module.exports.applyFunctions(config, value, prefix, suffix);
};


/**
 *  Trim the matched string, also remove the eventual = sign, then returns the string.
 */
module.exports.trimBeforeParse = function trim(string) {
    var trimmedString = string.trim();
    if (trimmedString.indexOf("=") === 0) trimmedString = trimmedString.substring(1); 
    if (trimmedString.indexOf(";") === trimmedString.length -1) 
        trimmedString = trimmedString.slice(0, -1);

    return trimmedString.replace(/\\n|\\r|\\/gi, "");
};


/**
 * Applies the functions to a string value
 */
module.exports.applyFunctions = function(config, value, prefix, suffix){
    //for each function in functions
    config.functions.forEach(function applyStringFunction(stringFunction) {
        var parameters = [];

        //if value is undefined, return it  
        if (!value) {
            return; 
        }

        if (!stringFunction.parameters) {
            return value = value[stringFunction.function]();
        }
        
        stringFunction.parameters.forEach(function(param, index) {
            // The first element of a replace can be a regex
            // If this isn't a replace, it's just a string
            if (stringFunction.function !== 'replace' && stringFunction.function !== 'search')
                return parameters.push(param);

            if (index > 0) 
                return parameters.push(param);

            if (typeof param === 'number')
                return parameters.push(param);
            

            var flags = param.flags || 'g';
            if (typeof param === 'object') {
                return parameters.push(new RegExp(param.regex, flags));
            }

            if (param === '') {
                return param;
            }

            return parameters.push(new RegExp(param, flags));
        });
      
        //log functions 
        Debug('Function ' + stringFunction.function + " with parameters " + parameters + " resulted in " + value);
        
        if (!value[stringFunction.function]) {
            throw new TypeError("Invalid function name '" + stringFunction.function + "' for type of " + typeof value);
        }

        var result = value[stringFunction.function].apply(value, parameters);
        
        //if we performed a slice, make sure the length is not 0
        if (stringFunction.function === "split" && result.length < 2) {
            result = null;
        }

        return value = result;
    });
   
    return value ? prefix + value + suffix : null;
};

/**
 *  Maps the conditions in the order they are presented, the first one that is true will return 
 *  its corresponding result, if none is true, default will be returned
 */
module.exports.conditionalMapper =  function(parent, mapping, json) {
    for (var condition in mapping.conditions) {
        if (mapping.conditions[condition].operator === 'and') {
            if (module.exports.andConditionalMapper(mapping.conditions[condition].conditions, json)) {
                return mapping.conditions[condition].result;
            }
        }

        if (mapping.conditions[condition].operator === 'or') {
            if (module.exports.orConditionalMapper(mapping.conditions[condition].conditions, json)) {
                return mapping.conditions[condition].result;
            }
        }
    }
    
    return mapping.default;
};


/**
 *  Mapper for the and condition
 */
module.exports.andConditionalMapper = function(conditions, json) {
    // For every condition, test it.
    // Return on the first fail
    for (var condition in conditions) {
        if (Hoek.reach(json, condition) !== conditions[condition]) {
            return false;
        }
    }

    return true;
};


/**
 *  Mapper for the or condition
 */
module.exports.orConditionalMapper = function(conditions, json) {
    // For every condition, test it.
    // Return on the first fail
    for (var condition in conditions) {
        if (Hoek.reach(json, condition) === conditions[condition]) {
            return true;
        }
    }

    return false;
};


/**
 * Maps the JSON endpoint response
 */ 
module.exports.mapJsonResponse = function(_variables, mapping, json) {
    if (!json) {
        return ;
    }
    
    if (mapping.type === 'string') {
        return module.exports.stringMapper(_variables, mapping, json);
    }

    if (mapping.type === 'number') {
        return module.exports.numberMapper(_variables, mapping, json);
    }

    if (mapping.type === 'array') {
        return module.exports.arrayMapper(_variables, mapping, json);
    }

    if (mapping.type === 'object') {
        return module.exports.objectMapper(_variables, mapping, json);
    }

    if (mapping.type === 'conditional') {
        return module.exports.conditionalMapper(_variables, mapping, json);
    }

    if (mapping.type === 'reference') {
        return module.exports.referenceMapper(_variables, mapping, json);
    }

    throw new Error("This config extractor is not supported: " + mapping.type + ".");
};

/**
 *  Reach a string withon a scraped JSONObject, trims if trim is set to true
 */ 
module.exports.stringMapper =  function(_variables, mapping, json) {
    var trim = mapping.trim || true,
        result = Hoek.reach(json, mapping.path);

    if (result && typeof result === "string" && trim) {
        result = result.trim();
    }

    //a string value should be processed, return it afterwards
    return module.exports.processStringValue(mapping, result);
};

/**
 *  Reaches for a number with the given path, removes all non numbers and parses it to float.
*/
module.exports.numberMapper = function(_variables, mapping, json) {
    return parseFloat(Hoek.reach(json, mapping.path).toString().replace(/[^0-9\.]+/g, ''));
};


/**
 *  Reaches for another object inside the JSON object and returns the item at the path
 */
module.exports.referenceMapper = function(_variables, mapping, json) {
    var targetObject,
        result;

    if (mapping.path.indexOf('_parent')) {
        targetObject = _variables.result;
    } else {
        targetObject = _variables.result;
    }

    result = targetObject[mapping.path];

    if (result) {
        return result;
    }

    return Hoek.reach(targetObject, mapping.path);
};

/**
 *  Maps each item in an array to a new array with functions corresponding to a new mapper,
 *  if no mapping.mapping is provided, then it returns original array
 */
module.exports.arrayMapper = function(_variables, mapping, json) {
    var array = Hoek.reach(json, mapping.path); 
    if (!mapping.mapping) {
        return array;
    }

    if (!array) {
        return;
    }

    // var res = array.map(JsonEndpointScraper.prototypearrayMapperFn.bind(this, parent, mapping));
    var res = array.map(module.exports.mapJsonResponse.bind(this, _variables,  mapping.mapping));
    return res;
};

/**
 *  Similar to the arrayMapper this function maps each key in the object to a new object with new function mappers.
 */
module.exports.objectMapper = function(_variables, mapping, json) {
    var object = {};
    
    for (var key in mapping.keys) {
        object[key] = module.exports.mapJsonResponse(_variables, mapping.keys[key], json);
    }

    return object;
};

/**
 *  Handles the conditions given, each mapping within the conditions will be handled in order
 */
module.exports.handleConditions = function(config, done) {
    if (!config["type"]) {
        throw new Error('Conditions must be provided with a type.');
    }
    
    if (!config["conditions"] || !Array.isArray(config['conditions'])) {
        throw new Error('Conditions must be provided and be an array.');
    }
    
    if (!config["true"] || !config["false"]) {
        throw new Error('Conditions must be provided with a true and false mapping.');
    }

    var conditionArray  = config['conditions'],
        that            = this;
       
    //callback function for each item in conditions
    var wrapper = function(item, callback) {
        module.exports.extractFromWithin(item, that._variables.html, function(err, result) {
            if (err) {
                DebugCondition('Condition ' + JSON.stringify(item, null, " ") + " " + resulted in error);
                DebugCondition(err);
                return callback();
            }
            
            return callback(err, result);
        }, that._variables);
    };

    //iterate all conditions in order
    Async.mapSeries(conditionArray, wrapper, function(err, results) {
        var pass = false,
            number; 
        
        //for http_status
        if (config.type === "followable") {
            return module.exports.checkLink(results[0], done);
        }

        if (results.length < 2) {
            throw new Error('There must be at least two conditions');
        }
    
        //assign pass the right value in terms of true or false
        switch (config.type) {
            //for eaqual
            case 'eq' :
                pass = _.uniq(results).length < 2;
                break;
    
            //for not equal
            case 'neq' :
                pass = _.uniq(results).length > 1;
                break;

            //for contains condition
            case 'contains' :
                var value = JSON.stringify(results[0]);
                
                if (!value) {
                    console.warn('No value in `contains` mapper, returning null.');
                    return done();
                }
                
                for (var i = 1; i < results.length; i++) {
                    var target = results[i] + '';
                    
                    if (value.indexOf(target) > -1) {
                        pass = true;
                        break;
                    }
                }

                break;
            
            //less than
            case 'lt' :
                for (var i = 1; i < results.length; i++) {
                    var  prevNumber = parseFloat(results[i - 1]),
                         thisNumber = parseFloat(results[i]);
                     
                    if (!isNaN(prevNumber) && !isNaN(thisNumber)) {
                        pass = prevNumber < thisNumber;  
                        
                        if (!pass) {
                            break;
                        }
                     } else {
                        console.warn('Result ' + results[i] + ' could not be converted to a string, returning null');
                        return done();
                     }
                }

                break;
            
            //greater than
            case 'gt' :
                for (var i = 1; i < results.length; i++) {
                    var  prevNumber = parseFloat(results[i - 1]),
                         thisNumber = parseFloat(results[i]);
                     
                     if (!isNaN(prevNumber) && !isNaN(thisNumber)) {
                        pass = prevNumber > thisNumber;  
                        
                        if (!pass) {
                            break;
                        }
                     } else {
                        console.warn('Result ' + results[i] + ' could not be converted to a string, returning null');
                        return done();
                     }
                }

                break;

            default : 
                throw new Error('The condition type ' + config.type + ' is not supported');
        }
        
        //by now pass must be either true or false
        return done(pass);
    });
};

/**
 *  Check if the url returns any html,
 *  returns true|false
 */
module.exports.checkLink = function(link, done) {
    Request(link, {timeout : 1000, method : 'head'} ,function(err, res, html) {
        if (!err && res.statusCode == 200) {
            return done(true);
        } 
    
        return done(false);
    });
}

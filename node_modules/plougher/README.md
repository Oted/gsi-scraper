plougher
========
[ ![Codeship Status for mallzee/plougher](https://www.codeship.io/projects/57510b30-2178-0132-5fae-5ac01ae581ac/status)](https://www.codeship.io/projects/36254)

Plougher
========

The ploughers purpose is to make life easier when scraping websites. It enables the user to provide a mapping which describes how the plougher should get the data at the given endpoint (html). Plougher then proceeds to iterate through the mapping and returns the result. 

The parameters of the plougher is either a url or html, and the mapping. 
```
var Plougher = require('plougher');
var plougher = new Plougher();

var callback = function(err, result) {
    console.log(result);
};

plougher.scrape(html, mapping, callback);

```

For easy debugging, this one liner in the node-terminal will run Plougher and print the result with the given mapping. Make sure to be in the root folder of Plougher when running it
```` 
.../plougher> node
> var mapping = {}; //your mapping goes here
> var urlOrHtml = "http://www.example.com/"; // url or html goes here
> var Plougher = require('./'); new Plougher().scrape(url, mapping, function(err, res){console.log(err, JSON.stringify(res, null, "  "))});
```` 

The mapping is defined in json. 
An example of it looks like this :
```json
{
    "extractor": "dom_object",
    "keys": {
        "link" : {
            "extractor": "dom_string",
            "path": "a#test",
            "attr" : "href"
        }
    }
}

```
In this case, the top `extractor` is defined as a `dom_object` which means that the final result will be an object with the given `keys` which in this case is only link.

The extractor at the key is a `dom_string`, meaning a plain string value. This value will be equal to the href attribute on the element with the id test, the result might look like this in the end. 
```json
{
    "link" : "http://localhost:80/"
}

```

##Extractors
Below is the complete set of the different extractor types. All of these types return their corresponding value to their parent until the root object is defined. In the example above the `dom_string` value is returned to the parent `dom_object` and the key link. Each extractor has it's own set of variables and scopes.

###dom_object
```json
{
    "extractor": "dom_object",
    "keys" : {
        "key1" : {...},
        "key2" : {...}
    }
}
```
This extractor creates a json object, each key must have its own corresponding extractor. This is usually the root extracor type, meaning that its allways at the top. This is usually because users usually want to have an object returned. Objects can also be chained meaning that the extractor of a key can be a new object, resulting in nested objects.

###dom_string
```json
{
    "extractor" : "dom_string",
    "path" : "any css selector (can use ref)",
    "type" : "string|number //defaults to string //optional",
    "attr" : "html attribute //can also be specifyed in the css selector",
    "strip" : "html|... //optional, removes html tags from the string",
    "prefix" : "//optional, add a prefix to the string (can use ref)",
    "suffix" : "//optional, add a suffix to the string (can use ref)",
    "follow" : "tries to follow the result //see `flags`, optional (can use ref)"
}
```
Creates one string value, often used as a terminal or a leaf in the mapping.
If `number` is provided, the value on the element will be parsed to a float number.

If number is provided as a type, all non digit characters will be removed.

###dom_array
```json
{
    "extractor" : "dom_array",
    "path" : "css selector (can use ref)",
    "type" : "string|object //defaults to string //optional",
    "attr" : "html attribute //can also be specifyed in the css selector"
}
```
Above is an example of how to specify the `dom_array` extractor, which is used to handle array's in your mapping. This extractor has two different types which is specified below. 

####type : string
If type `string` is provided then for each item found in the html found, a value will be added to the resulting array, this value could be a string or a number. Because type defaults to `string` it does not have to be specified.
```json
{
    "extractor": "dom_array",
    "path": "div.product-description ul li ul li",
    "attr" : "src",
    "flatten": "true, //optional",
    "join": "`.` //optional",
    "prefix" : "//optional, add a prefix to the string (can use ref)",
    "suffix" : "//optional, add a suffix to the string (can use ref)",
    "find" : "//optional finds the first element containing the specified value, this converst to a string (can use ref)",
    "find_attr" : "//optional together with find makes find looking on a different attribute on the element in the array",
    "filter" : "followable|contains_{{value}}... //optional, tries to follow the urls and filter out the ones that does not respond"
}
```
####type : object
If type `object` is provided then for each value found in the html, an object with the specified keys will be added. In the example below the result will be an array with objects each contining the keys images, name and urls. Where urls in this case is a new array.

```json
{
    "extractor": "dom_array",
    "path": "div.complete-the-look div.item",
    "type": "object",
    "mapping": {
        "extractor": "dom_object",
        "keys": {
            "images": {
                "extractor": "dom_string",
                "path": "a.item-link img",
                "attr": "data-href"
            },
            "name": {
                "extractor": "dom_string",
                "path": "a.item-link img",
                "attr": "alt"
            },
            "urls": {
                "extractor": "dom_array",
                "path": "div.product-description ul li ul li",
                "attr" : "src"
            }
        }
    }
}
```
###dom_script
```json
{
    "extractor" : "dom_script",
    "start_string" : "window.universal_variable",
    "end_string" : "match end string, //optional",
    "mapping": { 
        "type": "string",
        "path": "product.name"
    }
}
```
```html
<script>
    ...
    window.universal_variable = {
        "product": {
            "id": "123",
            "url": "http://localhost:80/",
            "name": "Mr.Plougher"
        },
        "version": "1.1.2"
    }
</script>
```
This extractor allows the user to extract varaibles within script tags with ease. The resulting segment of the script tag will be parsed to a json object. Meaning that the selected string must be a parsable json object. The mapping type provided is a `json mapping` and is used to easily extract data from a given json object (see section json_mapping). The flag end_string is optional and specifies where to match the end of the json to be parsed. In the case of the example above the end_string is not needed bacause of the fact thayt the json goes to the last line of the script. The final result of the above mapping would be "Mr.Plougher". 

###json_endpoint
```json
{
    "extractor": "json_endpoint",
    "request" : {
        "url": "http://localhost:8080/data/a_json_file.json", 
        "method" : "POST|GET",
        "gzip"    : "true, //optional, defaults to false"
    },
    "mapping": {
        "type": "array",
        "path": "d.SizeColours",
        "mapping": {
            "type": "string",
            "path": "Text"
        }
    }
}
```

The json_endpoint extractor becomes handy when the user need to get data from a foregin url that provides a json data format as response. Similary to the dom_script scraper the response is mapped with a json mapper. Plougjer uses the Request module for getting foregin urls, more about how what can be included in this mapping can be seen on https://github.com/mikeal/request

###reference
```json
{
    "extractor": "dom_object",
    "keys": {
        "ref": {
            "extractor": "reference",
            "value": "{{key1}}"
        }
    }
}

```
The reference extractor gets a value from an already extracted value in the result, in this case the key key1 at the root object. To reach values not at the root, you can use dot notation. like `key1.some_key_on_key1_object`. References is always surrounded in {{.}} and can be used pretty much anywhere. This also applies outside the reference extractor like in the case below where its used within a path of the 'dom_scraper' to specify the id of an element.

Keep in mind that the when following urls, the root object will be the object created with the follow mapping rather than the actual root at the original url.
```json
"details": {
    "extractor": "dom_string",
    "path": "div#details{{pid}}"
}
```

###constant
```json
{
    "extractor": "dom_object",
    "keys": {
        "name": {
            "extractor" : "constant",
            "value" : "hello world"
        }
    }
}
```
Constants are used to provide a constant result the value could be anything including objects, arrays and numbers in this case its a string value, the result in this case would be
```json
{
    "name" : "Hello world"
}
```
##Mapping json
Mapping a json object has a similar procedure to the mapping of the extractors. It is used primarly by the 'json_endpoint' and 'dom_script' and prodides a convenient way of getting the values out of a json object. Each `type` has to be provided with a `path` that represent the path to the value in the target object. The Value then also has to correspond to the specific type given. The types can be any of the following

###string
```json
"mapping": {
    "type": "string",
    "path": "product.name",
}
```

The string mapping is essentially the same as the 'dom_string' and can be provided with all of the same flags as a normal string value with the exception of `follow` and `try`.

###number
```json
"mapping": {
    "type": "number",
    "path": "product.price",
}
```
Parses the number at the path, this also replaces any non digits.

###array
Parses each item at in the array at the given path and maps them with the inner mapping.
```json
"mapping" : {
    "type": "array",
    "path": "d.SizeColours",
    "mapping": {
        "type": "string",
        "path": "Text"
    }
}
```

###object
Parses each item at in the object at the given path and maps them with the inner mapping.
```json
"mapping" : {
    "type": "array",
    "path": "d.SizeColours",
    "mapping": {
        "type": "string",
        "path": "Text"
    }
}
```

##Flags
This section provides information about special flags that either applies to all extractors or over some of them. 
###Functions
Functions applies on all values extracted with the extractors. They are powerful and should be used with care. Functions is a flag on the mapping like `path` or `attribute`. Its an array with functions applied in order which means that you can chain functions to a result and edit it. Here are some examples.
```json
"extractor": "dom_object",
"keys": {
    "name" : {
        "extractor" : "dom_string",
        "path"      : "div.title span.product_title",
        "functions" : [
            {
                "function" : "replace",
                "parameters" : [" ", ""]
            }
        ]
    }
}
```

The example above extracts a string value and removes all spaces.
```json
"pid": {
    "extractor": "dom_script",
    "start_string": "window.universal_variable",
    "mapping": {
        "path": "product.id",
        "type": "string",
        "functions": [
            {
                "function": "split",
                "parameters": ["-"]
            },
            {
                "function": "shift"
            }
        ]
    }
}
```
The example above extracts a string value with a `dom_script` extractor, splits the resulting string on the '-' character and shifts the array. This means that a result originally being "hi-there" will after the applied functions be "hi". More complex operations any function currently on the current values protoype can be used as long as it results in a value. This also means that a value can originally be a string but after a split become an array.

###Follow
The follow flag applies only to `dom_string` or `dom_array` with the type set to string. Putting the flag to true makes the Plougher assume that the string or strings is actual links, it will then proceed to follow them. An apply a given mapping to the new html. The plougher basically creates a new instance of itself with the new html. An example may look like this.
```json
"key" : {
    "extractor": "dom_string",
    "path": "a#test_link",
    "attr" : "href",
    "follow" : true,
    "mapping" : {
        "extractor": "dom_string",
        "path": "a#test_endpoint_url",
        "attr" : "href"
    }
}
```
The result of this mapping will be the value at `a#test_endpoint_url` on the html served on the url at `a#test_link`. Of cource the link at `a#test_link` must be valid, otherwise the result will be null. Heres a more complex example
```json
"key" : {
    "extractor": "dom_object",
    "keys": {
        "stock": {
            "extractor": "dom_array",
            "path": "li.square a",
            "add_current" : true, //optional
            "attr" : "href",
            "follow" : true,
            "mapping" : {
                "extractor": "dom_object",
                "keys" : {
                    "_id" : {
                        "extractor" : "dom_script",
                        "start_string" : "window.universal_variable",
                        "mapping": {
                            "type": "string",
                            "path": "product.color"
                        }
                    }
                }
            }
        }
    }
}
```
The result of this maping will be an array of objects, each link at the path `li.square a` will be followed and the provided mapping will be applied on all of the pages visited. Any mapping can be provided within the follow.mapping. The add current flag  applies the mapping to the current url aswell, and adding it to the array.

###Try
The try flag is wrapped around different extractors, trying them in the same order provided and the first one to not return null well be the final result returned. 
```json
test : {
    "try" : [
        {
            "extractor": "dom_string",
            "path": "a#test_esdsdsdndpoint_url",
            "attr" : "href"
        },
        {
            "extractor": "dom_string",
            "path": "a#test_link",
            "attr" : "href",
            "follow" : true,
            "mapping" : {
                "extractor": "dom_string",
                "path": "a#test_endpoint_url",
                "attr" : "href"
            }
        }
    ]
}
```
The value of the 'test' key will either be the value at `a#test_esdsdsdndpoint_url` if it returns a value (very unlikely). If it returns null, the value at the followed url will be returned instead. 

###Conditions
Conditions is a way to provide different results depending on values scraped. 
```json
{
    "extractor": "dom_object",
    "keys": {
        "equals" : {
            "type" : "eq",
            "conditions" : [
                {
                    "extractor": "dom_string",
                    "path": "a#test_endpoint_url1",
                    "attr" : "href"
                },
                {
                    "extractor": "dom_string",
                    "path": "a#test_endpoint_url2",
                    "attr" : "href"
                }
            ],
            "true" : {
                "extractor" : "constant",
                "value" : "yes"
            }, 
            "false" : {
                "extractor" : "constant",
                "value" : "no"
            }
        }
    }
}
```
If the hrefs given at `a#test_endpoint_url1` and `a#test_endpoint_url2` are equal the value at the mapping under true will be returned if they are not equal the mapping under false will be applied. Any number of values can be compared as long as they are at least two. The types can currently be `eq`, `neq` and `contains` which works with any value, `lt`, `gt` that works with numbers only and `followable` that works on urls and checks if they respond. Heres an example of the `gt` type.
```json
"equals" : {
    "type" : "gt",
    "conditions" : [
        {
            "extractor": "dom_string",
            "path": "a#number1"
        },
        {
            "extractor": "dom_string",
            "path": "a#number2"
        }                    
    ],
    "true" : {
        "extractor" : "constant",
        "value" : "yes"
    }, 
    "false" : {
        "extractor" : "constant",
        "value" : "no"
    }
}
```
Another one that checks if the first value `contains` the string 'this'
```json
{
    "test" : {
        "type" : "contains",
        "conditions" : [
            {
                "extractor": "dom_string",
                "path": "a#test_endpoint_url",
                "attr" : "href"
            },
            {
                "extractor" : "constant",
                "value" : "this"
            }
        ],
        "true" : {
            "extractor" : "constant",
            "value" : "yes"
        }, 
        "false" : {
            "extractor" : "constant",
            "value" : "no"
        }
    }
}
```
Another that check if a link 404s or not
```json
{
    "test" : {
        "type" : "followable",
        "conditions" : [
            {
                "extractor": "dom_string",
                "path": "a#test_endpoint_url",
                "attr" : "href"
            }
        ],
        "true" : {
            "extractor" : "constant",
            "value" : "yes"
        }, 
        "false" : {
            "extractor" : "constant",
            "value" : "no"
        }
    }
}
```
###Switch
The switch statement can be seen as a combination between try and conditionals, an example may look like this.
```json
{
    "extractor": "dom_object",
    "keys": {
        "colour" : {
            "target": {
                "extractor": "dom_string",
                "path": "li.product_colour span"
            },
            "switch": [
                {
                    "value": "SOMETHING",
                    "mapping": {
                        "extractor": "constant",
                        "value": 1
                    }
                },
                {
                    "value": "ASSORTED",
                    "mapping": {
                        "extractor": "constant",
                        "value": 0
                    }
                }
            ]
        }
    }
}

```
In this example, the value at the `target` is extracted and will be equal to 'ASSORTED'. Once this value is gathered, the plougher proceeds by comparing the `result` of `target` with each `value` in the switch array in a top down order. If `result` of `target` === `value` in `switch` then the final result in the switch statement will be the `mapping` under the found value.
![alt tag](https://mallzee-public-images.s3.amazonaws.com/Product-flow.jpg)
